## I.8.11.1 Method definitions

Method definitions are composed of a name, a method signature, and optionally an implementation of the method. The method signature defines the calling convention, type of the parameters to the method, and the return type of the method (see §[I.8.6.1](i.8.6.1-signatures.md)). The implementation is the code to execute when the method is invoked. A value type or object type shall define only one method of a given name and signature. However, a derived object type can have methods that are of the same name and signature as its base object type. See §[I.8.10.2](i.8.10.2-method-inheritance.md) and §[I.8.10.4](i.8.10.4-hiding-overriding-and-layout.md).

The name of the method is scoped to the type (see §[I.8.5.2](i.8.5.2-assemblies-and-scoping.md)). Methods can be given accessibility attributes (see §[I.8.5.3](i.8.5.3-visibility-accessibility-and-security.md)). Methods shall only be invoked with arguments whose types are *assignable-to* (§[I.8.7.3](i.8.7.3-general-assignment-compatibility.md)) the parameter types of the method signature. The type of the return value of the method shall also be *assignable-to* (§[I.8.7.3](i.8.7.3-general-assignment-compatibility.md)) the location in which it is stored.

Methods can be marked as **static**, indicating that the method is not an operation on values of the type but rather an operation associated with the type as a whole. Methods not marked as static define the valid operations on a value of a type. When a non-static method is invoked, a particular value of the type, referred to as **this** or the **this** pointer, is passed as the first parameter.

A method definition that does not include a method implementation shall be marked as **abstract**. All non-static methods of an interface definition are abstract. Abstract method definitions are only allowed in object types that are marked as abstract.

A non-static method definition in an object type can be marked as **virtual**, indicating that an alternate implementation can be provided in derived types. All non-static method definitions in interface definitions shall be virtual methods. Virtual method can be marked as **final**, indicating that derived object types are not allowed to override the method implementation.

Method definitions can be parameterized, a feature known as *generic method definitions*. When used, a specific instantiation of the generic method is made, at which point the generic parameters are bound to specific generic arguments. Generic methods can be defined as members of a non-generic type; or can be defined as members of a generic type, but parameterized by different generic parameter (or parameters) than its owner type. For example, the `Stack<T>` class might include a generic method `S ConvertTo<S> ()`, where the `S` generic parameter is distinct from the `T` generic parameter in `Stack<T>`.
