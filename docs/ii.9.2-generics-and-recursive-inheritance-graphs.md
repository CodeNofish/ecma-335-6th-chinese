## II.9.2 Generics and recursive inheritance graphs

_[Rationale:_ Although inheritance graphs cannot be directly cyclic, instantiations given in parent classes or interfaces may introduce either direct or indirect cyclic dependencies, some of which are allowed (e.g., `C : IComparable<C>`), and some of which are disallowed (e.g., `class A<T> : B<A<A<T>>>` given `class B<U>`). _end rationale]_

Each type definition shall generate a finite instantiation closure. An instantiation closure is defined as follows:

 1. Create a set containing a single generic type definition.

 2. Form the closure of this set by adding all generic types referenced in the type signatures of base classes and implemented interfaces of all types in the set. Include nested instantiations in this set, so a referenced type `Stack<List<T>>` actually counts as both `List<T>` and `Stack<List<T>>`.

 3. Construct a graph:

     * Whose nodes are the formal type parameters of types in the set. Use alpha-renaming as needed to avoid name clashes.

     * If _T_ appears as the actual type argument to be substituted for _U_ in some referenced type _D_\<&hellip;, _U_, &hellip;\> add a non-expanding (&rarr;) edge from _T_ to _U_.

     * If _T_ appears somewhere inside (but not as) the actual type argument to be substituted for _U_ in referenced type _D_\<&hellip;, _U_, &hellip;\> add an expanding (&rArr;) edge from _T_ to _U_.

An expanding-cycle is a cycle in the instantiation closure that contains at least one expanding-edge (&rArr;). The instantiation-closure of the system is finite if and only if the graph as constructed above contains no expanding-cycles.

_[Example:_

 ```csharp
 class B<U>
 class A<T> : B<A<A<T>>>
 ```

generates the edges (using &rArr; for expanding-edges and &rarr; for non-expanding-edges)

 * `T` &rarr; `T` (generated by referenced type `A<T>`)
 * `T` &rArr; `T` (generated by referenced type `A<A<T>>`)
 * `T` &rArr; `U` (generated by referenced type `B<A<A<T>>>`)

This graph does contain an expanding-cycle, so the instantiation closure is infinite. _end example]_

_[Example:_

 ```csharp
 class B<U>
 class A<T> : B<A<T>>
 ```

generates the edges

 * `T` &rarr; `T` (generated by referenced type `A<T>`)
 * `T` &rArr; `U` (generated by referenced type `B<A<T>>`)

This graph does not contain an expanding-cycle, so the instantiation closure is finite. _end example]_

_[Example:_

 ```csharp
 class P<T>
 class C<U,V> : P<D<V,U>>
 class D<W,X> : P<C<W,X>>
 ```

generates the edges

 * `U` &rarr; `X`, `V` &rarr; `W`, `U` &rArr; `T`, `V` &rArr; `T` (generated by referenced type `D<V,U>` and `P<D<V,U>>`)
 * `W` &rarr; `U`, `X` &rarr; `V`, `W` &rArr; `T`, `X` => `T` (generated by referenced type `C<W,X>` and `P<C<W,X>>`)

This graph contains non-expanding-cycles (e.g. `U` &rarr; `X` &rarr; `V` &rarr; `W` &rarr; `U`), but no expanding-cycle, so the instantiation closure is finite. _end example]_
